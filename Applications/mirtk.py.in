

## ^^^ Leave two lines blank at top which will be filled by CMake BASIS

##############################################################################
# Medical Image Registration ToolKit (MIRTK)
#
# Copyright 2013-2016 Imperial College London
# Copyright 2013-2016 Andreas Schuh
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################

import os
import sys
import socket
import subprocess

# ============================================================================
# environment
# ============================================================================

_config      = '@__CONFIG__@'
_libexec_dir = os.path.realpath(os.path.join(__dir__, '@LIBEXEC_DIR@'))
_paths       = [__dir__]
_ldpaths     = []

if _config:
    if not _libexec_dir.endswith('/mirtk'):
        _ldpaths.append(os.path.join(_libexec_dir, 'mirtk', _config))
    _ldpaths.append(os.path.join(_libexec_dir, _config))
if not _libexec_dir.endswith('/mirtk'):
    _ldpaths.append(os.path.join(_libexec_dir, 'mirtk'))
_ldpaths.append(_libexec_dir)

_paths.extend(_ldpaths)

_libexec_ext = ['']
if sys.platform.startswith('win'):
    _libexec_ext.extend(['.exe', '.cmd', '.bat'])

def _add_external_library_paths():
    for d in ['@MIRTK_LIBRARY_PATH_CONFIG@']:
        if d != '': _ldpaths.append(d)
_add_external_library_paths()

if sys.platform.startswith('linux'):
    _paths.extend(os.environ.get('PATH', '').split(':'))
    os.environ['PATH'] = ':'.join(_paths)
    _ldpaths.extend(os.environ.get('LD_LIBRARY_PATH', '').split(':'))
    os.environ['LD_LIBRARY_PATH'] = ':'.join(_ldpaths)
elif sys.platform.startswith('darwin'):
    _paths.extend(os.environ.get('PATH', '').split(':'))
    os.environ['PATH'] = ':'.join(_paths)
    _ldpaths.extend(os.environ.get('DYLD_LIBRARY_PATH', '').split(':'))
    os.environ['DYLD_LIBRARY_PATH'] = ':'.join(_ldpaths)
elif sys.platform.startswith('win'):
    _paths.extend(_ldpaths)
    _paths.extend(os.environ.get('PATH', '').split(';'))
    os.environ['PATH'] = ';'.join(_paths)

# ============================================================================
# help
# ============================================================================

# ----------------------------------------------------------------------------
def print_help():
    """Print help screen of this executable."""
    print("""
Usage:
  {0} [options] [--] <command> [options of command]
  {0} help <command>...
  {0} [options]

Description:
  This executable is a wrapper for the MIRTK commands. The name of the
  command to execute must be given as first argument.

Arguments:
  command   MIRTK command to execute.

Optional arguments:
  --help, -h      Print help and exit
  --verbose, -v   Print command-line of MIRTK command.
""".format(os.path.basename(__file__)))

# ============================================================================
# execute command
# ============================================================================

# ----------------------------------------------------------------------------
def call(argv):
    """Execute MIRTK command."""
    fpath = None
    fbase = _libexec_dir
    if os.path.basename(fbase) != 'mirtk':
        fbase = os.path.join(fbase, 'mirtk')
    for ext in _libexec_ext:
        fpath = os.path.join(fbase, _config, argv[0] + ext)
        if os.path.isfile(fpath): break
        else: fpath = None
    if not fpath:
        for ext in _libexec_ext:
            fpath = os.path.join(fbase, argv[0] + ext)
            if os.path.isfile(fpath): break
            else: fpath = None
        if not fpath:
            sys.stderr.write('Error: Missing execuable for command: ' + argv[0])
            return 1
    if not os.access(fpath, os.X_OK):
        sys.stderr.write('Error: Insufficient permissions to execute command: ' + fpath)
        return 1
    argv[0] = fpath
    if verbose > 0:
        args = []
        for arg in argv:
            if ' ' in arg: arg = '"' + arg + '"'
            args.append(arg)
        print(' '.join(args))
    return subprocess.call(argv)

# ============================================================================
# main
# ============================================================================

if __name__ == '__main__':
    verbose = 0
    argv    = []
    cmdarg  = False
    if len(sys.argv) < 2:
        print_help()
        sys.exit(1)
    for arg in sys.argv[1:]:
        if cmdarg:
            argv.append(arg)
        elif arg == '--':
            cmdarg = True
        elif arg == '-h' or arg == '-help' or arg == '--help':
            print_help()
            sys.exit(0)
        elif arg == '-v' or arg == '-verbose' or arg == '--verbose':
            verbose += 1
        elif not arg.startswith('-'):
            argv.append(arg)
            cmdarg = True
        else:
            sys.stderr.write('Error: Invalid option: ' + arg)
            sys.exit(1)
    if len(argv) == 0:
        print_help()
        sys.exit(1)
    if argv[0] == 'help':
        if len(argv) == 1:
            print_help()
        else:
            for cmd in argv[1:]:
                if call([cmd, '-h']) != 0:
                    sys.exit(1)
        sys.exit(0)
    else:
        if verbose > 1:
            print('\nHost: ' + socket.gethostname() + '\n')
        sys.exit(call(argv))
